"use strict";

class InternalRequest {
  type: string = "";
  setting?: string = "";
  value?: boolean = false;
  values?: Array<any>;
}

class InternalResponse {
  setting?: string;
  value?: boolean;
  values?: Map<string, boolean>;
}

// Generated by https://quicktype.io

class Options {
  tabs: Tab[] = [];
}

class Tab {
  name: string = "";
  fieldsets: Fieldset[] = [];
  helpUrl?: string;
}

class Fieldset {
  name: string = "";
  helpSection?: string;
  items: Item[] = [];
}

class Item {
  helpCheck?: string;
  name: string = "";
  id: string = "";
  resource_path: string = "";
  css: string[] | string | null = null;
  addScript?: string[] | string | null = null;
  removeScript?: string[] | string | null = null;
}

const clearAllOptions = document.getElementById("clearAllOptions")!;
const setAllOptions = document.getElementById("setAllOptions")!;

// The empty tab container element for the tab container
const tabContainer = document.getElementById("soup")!;

// The checked state of the popup. is in sync with the state on the content script.
let options = new Map<string, boolean>();

let invalidPage = false;

// The mapping between checkbox controls and the css and scripts
const eventConfig = new Map<HTMLInputElement, Item>();

// Create event handlers for the check all and uncheck all buttons
clearAllOptions!.addEventListener("click", function () {
  setAllCheckboxes(false);
});

setAllOptions!.addEventListener("click", function () {
  setAllCheckboxes(true);
});

// load the json file, and create the tabs
setupConfiguration(
  eventConfig,
  tabContainer ?? new HTMLElement(),
  "./options.json"
)
  // until we can use await here, we need to fake it with .then
  .then(() => {
    if (options == null || invalidPage) {
      return;
    }

    // setup the tab evets
    configureTabs();
  });

function isOptionsMap(options: any): options is Map<string, boolean> {
  return "get" in options && "has" in options && "set" in options;
}

// Loads the tab and checkbox setting from the json configuratiuon file
function loadConfiguration(resource: string): Promise<Options> {
  // Convert XMLHttpRequest from a callback to a promise that can be used with await.
  return new Promise((resolve, reject) => {
    let request = new XMLHttpRequest();
    // Create an event handler that fires when the request finishes.
    // This will create the promise when we finish.
    request.addEventListener("readystatechange", () => {
      if (request.readyState === 4 && request.status === 200) {
        let data: Options = JSON.parse(request.responseText);
        resolve(data);
      } else if (request.readyState === 4) {
        reject("error getting resources");
      }
    });

    // get the json file.
    request.open("GET", resource);
    request.send();
  });
}

// create the tabs and checkboxes from a JSON config file
async function setupConfiguration(
  eventConfig: Map<HTMLElement, Item>,
  container: HTMLElement,
  resource: string
) {
  await loadOptionsObject();

  if (invalidPage) {
    return;
  }
  const configuration = await loadConfiguration(resource);

  // Make sure our top level container hass the correct class...
  await container.classList.add("tabs");

  // Create a Tab List node to store the actual tab buttons.
  const tabList = document.createElement("div");
  tabList.role = "tablist";
  tabList.ariaLabel = "Quick check sections";
  container.appendChild(tabList);

  // Keep track of how many tabs we've created
  // There is no specific reason we're counting from 1, rather than 0, but you can use
  // whatever you want.
  const initialTabNumber = 1;
  let tabNumber = initialTabNumber;

  // Create an actual tab for each tab we have in the configuration
  for (const tabConfiguration of configuration.tabs) {
    // create the actual tab control itself
    const tabButton = document.createElement("button");
    tabButton.role = "tab";
    tabButton.id = "tab-" + tabNumber;

    // Only the first tab is selected
    tabButton.ariaSelected = (tabNumber === initialTabNumber).toString();

    // Only the initial tab is in the tab order. The rest can be programatically focussed.
    tabButton.tabIndex = tabNumber === initialTabNumber ? 0 : -1;

    tabButton.innerText = tabConfiguration.name;

    // Create the tabPanel to store the controls.
    const tabPanel = document.createElement("div");
    tabPanel.id = "panel-" + tabNumber;
    tabPanel.role = "tabpanel";

    // all but the first panel are hidden
    if (tabNumber !== initialTabNumber) {
      tabPanel.hidden = true;
    }

    // insert the tab and panel to their container
    tabList.appendChild(tabButton);
    container.appendChild(tabPanel);

    // link the tab button and the tabPannel
    tabButton.setAttribute("aria-controls", tabPanel.id);
    tabPanel.setAttribute("aria-labelledby", tabButton.id);
    
    // Create the "Check All" checkbox
    const checkAllCheckbox = document.createElement("input");
    checkAllCheckbox.type = "checkbox";
    checkAllCheckbox.id = `check-all-${tabNumber}`;
    checkAllCheckbox.classList.add("check-all");

    const checkAllLabel = document.createElement("label");
    checkAllLabel.htmlFor = checkAllCheckbox.id;

    // Append the tab name to the end of the "Check All" label
    checkAllLabel.innerText = `Check All - ${tabConfiguration.name}`;

    // Create a div container to wrap the checkbox and its label
    const checkAllWrapper = document.createElement("div");
    checkAllWrapper.classList.add("check-all-wrapper-7786978");

    // Append the checkbox and the label to the div container
    checkAllWrapper.appendChild(checkAllCheckbox);
    checkAllWrapper.appendChild(checkAllLabel);

    // Add the div container to the tabPanel
    tabPanel.appendChild(checkAllWrapper);

    // setup fieldsets for the checkbox groupings
    for (const fieldsetConfiguration of tabConfiguration.fieldsets) {
      const fieldset = document.createElement("fieldset");

      //  Make sure it has a legend
      const legend = document.createElement("legend");
      legend.innerText = fieldsetConfiguration.name;
      fieldset.appendChild(legend);

      // Optional help text for the section
      if (fieldsetConfiguration.helpSection) {
        const helpText = document.createElement("p");
        helpText.innerText = fieldsetConfiguration.helpSection;
        helpText.classList.add("help-section-7726536");
        fieldset.appendChild(helpText);
      }

      // We use a DIV wrapper
      const divWrapper = document.createElement("div");
      divWrapper.classList.add("column--container-299867");

      // We use a list for the controls
      const list = document.createElement("ul");
      divWrapper.appendChild(list);

      // create the checkboxes
      for (const checkboxConfiguration of fieldsetConfiguration.items) {
        // Create list Item - we're within a UL here
        const listItem = document.createElement("li");
        listItem.classList.add("listItem-299867");

        // Optional help text for the item
        if (checkboxConfiguration.helpCheck) {
          const helpText = document.createElement("p");
          helpText.innerText = checkboxConfiguration.helpCheck;
          helpText.classList.add("help-check-77265");
          listItem.appendChild(helpText);
        }

        // Add the divWrapper element to the fieldset element
        fieldset.appendChild(divWrapper);

        // Check the number of li elements and add a class to the divWrapper element if necessary
        //const liCount = list.querySelectorAll("li").length;

        // if (liCount > 5) {
        //   divWrapper.classList.add("multi-column--container-299867");
        // }

        // create the input element
        const checkBox = document.createElement("input");
        checkBox.id = checkboxConfiguration.id;
        checkBox.type = "checkbox";

        // make sure we add the checkbox to the dom
        listItem.appendChild(checkBox);

        // Create the label
        const label = document.createElement("label");
        label.classList.add("switch--label-88947");

        // I'm not sure why we have a span within the label
        const span = document.createElement("span");
        span.classList.add("label");

        // give the label some text
        span.innerHTML = checkboxConfiguration.name;

        // add the span to the label
        label.appendChild(span);

        // link the label to the checkbox
        label.htmlFor = checkBox.id;

        // hook the label into the list item's DOM
        listItem.appendChild(label);

        // hook the listitem into the DOM
        list.appendChild(listItem);

        // get the current checkbox state for the checkbox.
        // We need to do this before we install teh event handkler to stop it from triggering.
        await loadCheckboxValue(checkBox);

        // hookup the event listener so we get the click events
        checkBox.addEventListener("change", async (event) => {
          await checkboxEventHandler(event);
        });

        // Get the add/remove scripts and CSS files for this checkbox
        const resources = new Item();

        // ensure the path starts with, and ends with a /
        let path = checkboxConfiguration.resource_path;
        if (path.substring(0, 1) !== "/") {
          path = "/" + path;
        }
        if (path.substring(path.length - 1) !== "/") {
          path += "/";
        }
        if (checkboxConfiguration.css != null) {
          if (Array.isArray(checkboxConfiguration.css)) {
            resources.css = checkboxConfiguration.css.map(
              (scriptFilename) => path + scriptFilename
            );
          } else {
            resources.css = path + checkboxConfiguration.css;
          }
        }
        if (Object.hasOwn(checkboxConfiguration, "addScript")) {
          if (checkboxConfiguration.addScript instanceof Array) {
            resources["addScript"] = checkboxConfiguration.addScript.map(
              (scriptFilename) => path + scriptFilename
            );
          } else {
            resources["addScript"] = path + checkboxConfiguration.addScript;
          }
        }

        if (Object.hasOwn(checkboxConfiguration, "removeScript")) {
          if (checkboxConfiguration.removeScript instanceof Array) {
            resources["removeScript"] = checkboxConfiguration.removeScript.map(
              (scriptFilename) => path + scriptFilename
            );
          } else {
            resources["removeScript"] =
              path + checkboxConfiguration.removeScript;
          }
        }

        // add the resources to the map, using the checkbox element itself as the key.
        eventConfig.set(checkBox, resources);
      }

      // Hook the fieldset into the tab panel's DOM
      tabPanel.appendChild(fieldset);
    }

    // make sure we change this to ensure a unique tab
    tabNumber += 1;

    checkAllCheckbox.addEventListener("change", function () {
      const checkboxes = tabPanel.querySelectorAll(
        "input[type='checkbox']:not(.check-all)"
      );
      checkboxes.forEach((checkboxElement) => {
        if (checkboxElement instanceof HTMLInputElement) {
          // Check to ensure it's an HTMLInputElement
          checkboxElement.checked = checkAllCheckbox.checked;
        }
      });
    });

    const helpLink = document.createElement("a");
    helpLink.innerText = "Help and Instructions";
    helpLink.classList.add("help-link");

    if (tabConfiguration.helpUrl) {
      helpLink.href = chrome.runtime.getURL(tabConfiguration.helpUrl);
    } else {
      helpLink.href = "#"; // Fallback to placeholder if no helpUrl is provided.
    }

    // Logic to Check or Uncheck the "Check All" Checkbox**
    tabPanel.addEventListener("change", function (event) {
      const targetCheckbox = event.target;
      if (
        targetCheckbox instanceof HTMLInputElement &&
        targetCheckbox !== checkAllCheckbox &&
        !checkAllCheckbox.checked
      ) {
        const checkboxes = tabPanel.querySelectorAll(
          "input[type='checkbox']:not(.check-all')"
        );
        if (
          Array.from(checkboxes).every(
            (checkboxElement) =>
              checkboxElement instanceof HTMLInputElement &&
              checkboxElement.checked
          )
        ) {
          // Check to ensure it's an HTMLInputElement
          checkAllCheckbox.checked = true;
        } else {
          checkAllCheckbox.checked = false;
        }
      }
    });

    // Add an event listener to open the help URL in a new Chrome window
    helpLink.addEventListener("click", (e) => {
      if (helpLink.href !== "#") {
        // If href is not a placeholder
        e.preventDefault();
        chrome.windows.create({
          url: helpLink.href,
          type: "popup",
          width: 800,
          height: 600,
        });
      }
    });

    tabPanel.appendChild(helpLink);
  }
}

// Gets the value from the session storage, and sets the checkbox appropriately
// The checkbox is passed in, and the id is used to look up the saved value, but the checkbox itself's
// checked proeprty is updated directly
async function loadCheckboxValue(checkbox: HTMLInputElement) {
  const checkboxName = checkbox.id;

  let checked = false;

  // If we don't have a value, assume it's false, and save it back.
  if (!options.has(checkboxName)) {
    options.set(checkboxName, checked);
    await saveOptionsObject();
  }

  checked = options.get(checkboxName)!;

  checkbox.checked = checked;
}

// saves the checkbox value to session storage
async function saveCheckboxValue(checkbox: HTMLInputElement) {
  const checkboxName = checkbox.id;

  options.set(checkboxName, checkbox.checked);

  await saveOptionsObject();
}

// Loads the options from session storage
async function loadOptionsObject() {
  let rawResponse: any;
  const request = new InternalRequest();
  request.type = "getSettings";
  try {
    rawResponse = await chrome.tabs.sendMessage(await getTabId(), request, {
      frameId: 0,
    });
  } catch (err) {
    // if that didn't work, assume the script isn't loaded in the tab, and re try after loading the script.
    try {
      await chrome.scripting.executeScript({
        target: {
          tabId: await getTabId(),
          allFrames: false,
        },
        files: ["/extension/content-setting.js", "checks/common.js"],
      });
    } catch (err2: any) {
      if (err2 instanceof Error) {
        // Check if we're trying to access a page that we can't.
        // This may need to be expanded in the future
        if (
          err2.message.toLowerCase().includes("cannot access") ||
          err2.message.toLowerCase().includes("cannot be scripted.") ||
          err2.message.toLowerCase().includes("no tab with id")
        ) {
          console.log("Failed to get permission to insert the scripts");
          clearAllOptions.remove();
          setAllOptions.remove();
          tabContainer.innerHTML =
            "<p>The browser has prevented the extension from accessing this tab.</p>";
          options = new Map<string, boolean>();
          invalidPage = true;
          return;
        }
      }
      throw err2;
    }
    console.log(`getMessage err1 ${err}`);
    rawResponse = await chrome.tabs.sendMessage(await getTabId(), request, {
      frameId: 0,
    });
  }

  const response = new InternalResponse();
  response.values = rawResponse.values.reduce(
    (newMap: Map<string, boolean>, valuePair: Array<any>) =>
      newMap.set(valuePair[0], valuePair[1]),
    new Map<string, boolean>()
  );
  options = response.values!;
}

// Save the options to session storage
async function saveOptionsObject() {
  if (options.size > 0) {
    const request = new InternalRequest();
    request.type = "putSettings";
    request.values = Array.from(options.entries());
    chrome.tabs.sendMessage(await getTabId(), request, { frameId: 0 });
  }
}

async function getTabId(): Promise<number> {
  const [tab] = await chrome.tabs.query({
    active: true,
    currentWindow: true,
  });

  return tab!.id!;
}

// Inserts cssFileName css file into the active tab
async function insertCSS(cssFileName: string | Array<string>) {
  let argumentArray: Array<string>;

  if (cssFileName instanceof Array) {
    argumentArray = cssFileName;
  } else {
    argumentArray = [cssFileName];
  }
  try {
    await chrome.scripting.insertCSS({
      target: {
        tabId: await getTabId(),
        allFrames: true,
      },
      files: argumentArray,
    });
  } catch (err) {
    console.error(`failed to insert ${cssFileName} CSS: ${err}`);
  }
}

// Removes cssFileName css file from the active tab
async function removeCSS(cssFileName: string | Array<string>) {
  let argumentArray: Array<string>;

  if (cssFileName instanceof Array) {
    argumentArray = cssFileName;
  } else {
    argumentArray = [cssFileName];
  }

  try {
    await chrome.scripting.removeCSS({
      target: {
        tabId: await getTabId(),
        allFrames: true,
      },
      files: argumentArray,
    });
  } catch (err) {
    console.error(`failed to remove ${cssFileName} CSS: ${err}`);
  }
}

// Execute script in active tab. You can pass a string for one file, or an array for multiple
async function executeScript(scriptFileName: string | Array<string>) {
  try {
    let argumentArray;
    if (scriptFileName instanceof Array) {
      argumentArray = scriptFileName;
    } else {
      argumentArray = [scriptFileName];
    }
    await chrome.scripting.executeScript({
      target: {
        tabId: await getTabId(),
        allFrames: true,
      },
      files: argumentArray,
    });
  } catch (err) {
    console.error(`failed to execute ${scriptFileName} script: ${err}`);
  }
}

// Change a checkbox's value, and fire the changed event. Use this to force ensure the event handler is run
// so the action happens
function setCheckboxValueWithChangeEvent(
  checkbox: HTMLInputElement,
  value: boolean,
  force: boolean = false
) {
  if (force == true || checkbox.checked != value) {
    checkbox.checked = value;
    const event = new Event("change");
    checkbox.dispatchEvent(event);
  }
}

// set all checkboxes to the value of state
function setAllCheckboxes(state: boolean) {
  // loop through the eventConfig keys (which are the checkbox elements) and update their values
  for (const checkBox of eventConfig.keys()) {
    setCheckboxValueWithChangeEvent(checkBox, state, false);
  }
}

// a generic event handler that will look up eventConfig for the correct actions
async function checkboxEventHandler(event: Event) {
  if (event.type !== "change") {
    return;
  }
  const target = event.target!;

  if (!(target instanceof HTMLInputElement)) {
    return;
  }
  const handlerConfig = eventConfig.get(target);
  if (handlerConfig == null) {
    return;
  }

  await saveCheckboxValue(target);

  if (target.checked) {
    if (handlerConfig.css != null) {
      await insertCSS(handlerConfig.css);
    }
    if (handlerConfig.addScript != null) {
      await executeScript(handlerConfig.addScript);
    }
  } else {
    if (handlerConfig.css != null) {
      await removeCSS(handlerConfig.css);
    }
    if (handlerConfig.removeScript != null) {
      await executeScript(handlerConfig.removeScript);
    }
  }
}
